{
  "hash": "6763eb86f40e7e09782e2f1ca88d1d71",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Local setup for working with Overture data\"\n# css: [pres_style.scss,default]\nexecute: \n  echo: true\n  eval: true\n  include: true\nipynb-shell-interactivity: all\nkeep-ipynb: true\nformat: \n  revealjs: \n    theme: [pres_style.scss,default]\n    fig-align: center\n    code-fold: false\nauthor: \n  - name: Ivann Schlosser\n    email: ivann.schlosser@ox.co.uk\n    url: ischlosser.com\n    affiliations:\n      - name: Oxford Progamme for Sustainable Infrastructure Systems (OPSIS)\n        address: South Parks Road\n        postal-code: OX1 3QY\n        city: Oxford\n---\n\n## Importing the data\n\nThe Overture website recommends various workflows to download the data. Among them, the one allowing to work a local and self-sufficient manner is the python based [`overturemaps`](https://github.com/OvertureMaps/overturemaps-py) CLI, available from pip. It requires few arguments: 4 numeric values for the bbox, the type of layer to extract and the type of file to write into.\n\n::: {#2024d18b .cell execution_count=1}\n``` {.python .cell-code}\n!overturemaps download --bbox=west,south,east,north -f geoparquet --type=segment -o tanzania_roads.geoparquet\n```\n:::\n\n\nMore information on the values allowed in `--type` is available via the shell command `overturemaps download --help`. More methods to download Overture data are shown in the [documentation](https://docs.overturemaps.org/getting-data/){target=\"_blank\"}.\n\n## Working with the data\n\nOnce the data is stored locally as `.geoparquet`, we can work with it in python with `duckdb`.\n\n\n\n::: {#8f2612c7 .cell execution_count=3}\n``` {.python .cell-code}\nimport duckdb as db\n\nroads = db.read_parquet(\"../tanzania_roads.geoparquet\")\n```\n:::\n\n\nThe data set is read as traditional parquet in which the geometry column is a `blob`.\n\n::: {#b9a59d27 .cell execution_count=4}\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n┌──────────────────────┬──────────────┬────────────────────────────────────────────────────────────────────────────────┐\n│          id          │    class     │                                    geometry                                    │\n│       varchar        │   varchar    │                                      blob                                      │\n├──────────────────────┼──────────────┼────────────────────────────────────────────────────────────────────────────────┤\n│ 089962508d97ffff04…  │ path         │ \\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x02@<\\xD1\\xA5\\x99\\x82\\x1C\\xA5\\xC01.1\\x0D\\xB…  │\n│ 089962508d97ffff04…  │ path         │ \\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x08@<\\xD1\\xD2\\x08u\\xF0G\\xC01.\\x0A+\\xD2\\xEC\\…  │\n│ 088962508d9fffff04…  │ path         │ \\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x13@<\\xD1\\xA5\\x99\\x82\\x1C\\xA5\\xC01.1\\x0D\\xB…  │\n│ 089962508d83ffff04…  │ path         │ \\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x0B@<\\xD2\\x06\\xEF\\x07\\x8A8\\xC01-\\xE34\\x17^\\…  │\n│ 08496251ffffffff04…  │ secondary    │ \\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00c@<\\xC7\\xF8\\xAA\\xA1(\\xDA\\xC01&_\\xB8\\xCD;\\x88…  │\n│ 086962508fffffff04…  │ unclassified │ \\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00S@<\\xD2\\x16/\\x16n\\x01\\xC01!\\xD4\\x96\\xC5\\xA9\\…  │\n│ 08496251ffffffff04…  │ unclassified │ \\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x01\\x05@<\\xD2\\x16/\\x16n\\x01\\xC01!\\xD4\\x96\\xC5\\x…  │\n│ 087962508bffffff04…  │ track        │ \\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00!@<\\xD3\\x9A\\x93\\x94\\x9C\\xDB\\xC01!\\xB0\\xFA\\x0…  │\n│ 086962508fffffff04…  │ track        │ \\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00:@<\\xD4\\xB9\\x9F\\xC9^\\x83\\xC01\\x1En\\xE9\\xC2\\x…  │\n│ 087962508bffffff04…  │ track        │ \\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x003@<\\xD1\\xBA\\x0B\\xFF\\xE8\\x83\\xC01\\x1Ew\\xA7\\xD…  │\n├──────────────────────┴──────────────┴────────────────────────────────────────────────────────────────────────────────┤\n│ 10 rows                                                                                                    3 columns │\n└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘\n```\n:::\n:::\n\n\nThe `duckdb` loaders do not support reading *geoparquet* at the moment, but this feature is expected in the upcoming version. We stick to this format for its efficiency when storing large extracts.\n\nTo further work with the geometry, we install the `duckdb` extension.\n\n::: {#774b2d91 .cell execution_count=5}\n``` {.python .cell-code}\n# installing and loading the extension.\ndb.install_extension(\"spatial\")\ndb.load_extension(\"spatial\")\n```\n:::\n\n\nThis will allow us to work with the geometry column from within the database, bypassing the limitation of the parquet reader.\n\n## Basic interaction with the data\n\nStill with the `duckdb` package and its SQL-like syntax.\n\n#### Counting values\n\n::: {#394c31bf .cell execution_count=6}\n``` {.python .cell-code}\ndb.sql(\"SELECT count(*) as N_segments,class FROM roads GROUP BY class;\")\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n┌────────────┬───────────────┐\n│ N_segments │     class     │\n│   int64    │    varchar    │\n├────────────┼───────────────┤\n│      83290 │ unknown       │\n│       3974 │ driveway      │\n│    1249548 │ path          │\n│       1481 │ parking_aisle │\n│        144 │ cycleway      │\n│        263 │ crosswalk     │\n│        459 │ alley         │\n│         29 │ bridleway     │\n│    1792660 │ residential   │\n│      27548 │ primary       │\n│      44763 │ trunk         │\n│        373 │ steps         │\n│         93 │ NULL          │\n│        457 │ pedestrian    │\n│         63 │ motorway      │\n│    1128458 │ unclassified  │\n│     148719 │ tertiary      │\n│        319 │ sidewalk      │\n│       2473 │ living_street │\n│     502882 │ track         │\n│      69192 │ secondary     │\n│      57044 │ footway       │\n├────────────┴───────────────┤\n│ 22 rows          2 columns │\n└────────────────────────────┘\n```\n:::\n:::\n\n\n## Data Manipulation\n\nThe advantage of working with `duckdb` is that intensive computations are performed outside the python environment, and all we need to do is *collect* the results.\n\n### Etracting a subset\n\n::: {#45bbc7fc .cell execution_count=7}\n``` {.python .cell-code}\n# filtering out cycleways\nways = db.sql(\"Select id,ST_GeomFromWKB(geometry) as geometry,subtype,class from roads where class='primary';\")\n\n# intermediate step: transform the geometry into WKT and read the subset of data as a pandas DataFrame\nways_wkt = db.sql(\"select id, ST_AsText(geometry) as geometry, subtype, class from ways;\").df()\n\n# Finally, convert the geometry and create a geopandas GeoDataFrame. \nways_df = gpd.GeoDataFrame(ways_wkt\n                          ,geometry=gpd.GeoSeries.from_wkt(ways_wkt[\"geometry\"])\n                          ,crs=4326\n                          )\nways_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id</th>\n      <th>geometry</th>\n      <th>subtype</th>\n      <th>class</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>088971928a1fffff047fb94fc9b6da63</td>\n      <td>LINESTRING (30.87546 -17.07291, 30.87616 -17.0...</td>\n      <td>road</td>\n      <td>primary</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>08497193ffffffff047fafebb6014c10</td>\n      <td>LINESTRING (30.86457 -17.04400, 30.86431 -17.0...</td>\n      <td>road</td>\n      <td>primary</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>08896269203fffff047daff58b6ae4c4</td>\n      <td>LINESTRING (30.84229 -17.03138, 30.84201 -17.0...</td>\n      <td>road</td>\n      <td>primary</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>089962692037ffff047fee1fd2e8c575</td>\n      <td>LINESTRING (30.84418 -17.03071, 30.84229 -17.0...</td>\n      <td>road</td>\n      <td>primary</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>08a962692022ffff047ffd55846af8dc</td>\n      <td>LINESTRING (30.84504 -17.03038, 30.84418 -17.0...</td>\n      <td>road</td>\n      <td>primary</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe resulting types:\n\n::: {#1c79a6b9 .cell execution_count=8}\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nid            object\ngeometry    geometry\nsubtype       object\nclass         object\ndtype: object\n```\n:::\n:::\n\n\n## Plotting\n\n::: {#3f6ab66e .cell execution_count=9}\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nText(0.5, 1.0, 'Example segment class')\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nText(0.5, 25.13333333333333, 'Longitude [deg]')\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nText(303.74186744197146, 0.5, 'Latitude [deg]')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-revealjs/cell-10-output-4.png){width=353 height=449 fig-align='center'}\n:::\n:::\n\n\n## Other workflows\n\n### GeoPandas\n\nOnce the data is extracted, other options are available to work with it. `GeoPandas` converts the geometry column for us, so no extra steps are required.\n\n::: {#cc091e2c .cell execution_count=10}\n``` {.python .cell-code}\nways_gpd = gpd.read_parquet(\"../tanzania_roads.geoparquet\"\n                        #  ,columns=[\"id\",\"class\",\"connector_ids\",\"geometry\"] # read in desired columns only.\n                         )\n\n```\n:::\n\n\nIt is however less efficient to read with this method, so it's only recommended for relatively small data sets.\n\n### pyArrow\n\nIs the under the hood reader of `geopandas`.\n\n::: {#3f1ade06 .cell execution_count=11}\n``` {.python .cell-code}\nimport pyarrow.parquet as pq\n\nways_arrow = pq.read_table(\"../tanzania_roads.geoparquet\")\n```\n:::\n\n\n### Still more tools\n\nThe vast python package ecosystem provides a wide range of tools that work with (geo)parquet and (geo)arrow file formats and specifications, among them:\n\n-   [geoarrow](https://github.com/geoarrow/geoarrow-python){target=\"_blank\"}: the low level specification of parquet.\n-   [geoparquet](https://github.com/darcy-r/geoparquet-python){target=\"_blank\"}\n\n",
    "supporting": [
      "index_files/figure-revealjs"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}